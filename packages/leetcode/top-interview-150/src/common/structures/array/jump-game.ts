/*
 * @lc app=leetcode id=55 lang=typescript
 *
 * [55] Jump Game
 */

// @lc code=start
function canJump(nums: number[]): boolean {
  // 到达每个位置，可以新获取该位置的跳跃步数，但是步数不累加。比如某个位置i跳到位置r，如果i获取了3个步伐，用了2个步伐到达r，那么在r上获取到的步伐不会跟剩余步伐3-2=1累加。而是“能走的步伐” =位置r获取的步伐。

  // 假如我们能够到达x位置，那么我们就能够到达x + (0...nums[x]）这个范围内的位置
  // 我们一定能够来到位置0，那么我们就能够来到0 + (0...nums[0])这个范围内的位置
  // 当我们尝试判断位置1，那么我们看下刚刚0所能够到达的位置范围里有没有1，也就是0+(nums[0]) >= 1;
  // 当我们确定能够来到位置1，那么我们就看下从1开始最远能够到达的位置，也就是1+ (0...nums[1])范围，更新这个范围

  let max = nums[0];

  // 遍历所有位置，查看是否能够到达
  for (let i = 1; i < nums.length; i++) {
    // 如果当前最远能跑到的位置范围里头有i，说明i位置能够到达
    if (max >= i) {
      // 在i位置能够到达的情况下，我们看下i位置开始能够跳跃的步数到达的范围是否比max范围还要大，是的话更新一下。因为我们需要越远越好，尽量拿到足够支撑到达终点的范围，这样子我们在终点位置的时候就可以拿(max>=i)判断是否能够到达该位置了
      max = Math.max(i + nums[i], max);
    }
    else {
      // 如果在终点包括其之前的范围都通过max判断没法到达，那就返回false不可能到达
      return false;
    }
  }

  return true;
};
// @lc code=end

export const jump_game = canJump;
