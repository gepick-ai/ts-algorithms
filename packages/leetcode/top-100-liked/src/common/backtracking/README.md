# 回溯算法

## 回溯三问

1. 当前操作？
2. 子问题？
3. 下一个子问题？

## 问题归类

- 子集型回溯：每个元素都可以选或者不选。要生成子集有两种思路，区别在于当前操作是什么：
  - 输入角度：dfs(i)从下标>=i的数字中构造子集
    - 当前操作：枚举第i个数选/不选
    - 子问题：从下标>=i的数字中构造子集
    - 下一个子问题：从下标>=i+1的数字中构造子集。dfs(i) -> dfs(i+1)

  - 输出角度：子集问题不考虑顺序，为了避免重复我们就规定顺序，让它严格递增
    - 当前操作：每次必须选一个数。枚举下标j>=i的数字，加入path
    - 子问题：从下标>=i的数字中构造子集
    - 下一个子问题：从下标>=j+1的数字中构造子集。

- 组合型回溯
- 排列型回溯：进入每层都使用一个新的辅助set用来存储当前层能够候选的数有哪些。

## 技巧

- 定长可以使用数组，`path[i]`本身能够覆盖旧元素，相当于恢复现场