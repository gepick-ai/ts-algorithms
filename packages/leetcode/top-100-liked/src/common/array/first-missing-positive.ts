/*
 * @lc app=leetcode id=41 lang=typescript
 *
 * [41] First Missing Positive
 */

// @lc code=start
function firstMissingPositive(nums: number[]): number {
  const n = nums.length;

  // 将所有数都归位到正确的位置
  for (let i = 0; i < n; i++) {
    // 1 <= nums[i] && nums[i] <= n 说明数在1到N之间
    // 但是这样行不通，因为可能有数字重复，比如[3,4,3,1]，3应该放在nums[2]的位置，但是nums[2]的位置已经有一个3了，我们需要处理这个情况，否则就是死循环了。
    // 我们的处理方式是，判断nums[i]要去的地方是否已经是正确的数了，如果是，那么说明nums[i]已经归位了，直接跳过。代码上我们用nums[i] !== nums[nums[i] - 1]来判断。
    while (nums[i] > 0 && nums[i] <= n && nums[i] !== nums[nums[i] - 1]) {
      // 按照数组的位置来放置，那么nums[i]应该放在nums[i] - 1的位置，比如nums[i] = 3，那么3应该放在nums[2]的位置
      const j = nums[i] - 1; // 减一是因为数组下标从 0 开始。
      [nums[i], nums[j]] = [nums[j], nums[i]]; // 把nums[i]的数交换到正确位置，但是我们需要继续查看现在nums[i]的数是否正确，所以需要继续while循环
    }
  }

  // 在所有数都归位到正确的位置后，我们开始检查每个位置，看下该位置的数是否正确。数组中每个位置的数都应该是i+1，因为数组下标从0开始，所以i+1就是该位置的数。
  for (let i = 0; i < n; i++) {
    if (nums[i] !== i + 1) {
      return i + 1;
    }
  }

  // 如果1到N都在数组中，那就返回N+1
  return n + 1;
};
// @lc code=end

/**
 * {@include ../../../../../../.typedoc/problems/41.缺失的第一个正数.md}
 *
 * @summary
 * ### 41. 缺失的第一个正数
 *
 * 给你一个未排序的整数数组 nums，请你找出其中没有出现的最小的正整数。
 *
 * 你必须在 O(n) 时间复杂度、常数级空间复杂度下完成解决方案。
 *
 * **举例说明：**
 *
 * - 输入: [1,2,0]
 *   输出: 3
 *   解释: 1 和 2 都在数组中，最小缺失的是 3
 *
 * - 输入: [3,4,-1,1]
 *   输出: 2
 *   解释: 1 和 3、4 在数组中，2 没有出现
 *
 * - 输入: [7,8,9,11,12]
 *   输出: 1
 *   解释: 1 没有出现
 *
 * **总结：**
 *
 * - 题目要我们找的是从 1 开始往上数，第一个没有在数组中出现的正整数。
 * - 要求 O(n) 时间和 O(1) 额外空间（原地修改数组）。
 *
 * @answer
 * - 举例1：[1,2,3]长度为3的数组，缺失的第一个正数是4。这说明如果N=3，那么从1开始数到3，我们都能在数组找到，那第一个没有出现的正数就是4。
 * - 举例2：[0,2,3]长度为3的数组，缺失的第一个正数是1。这说明如果N=3，那么从1开始数到3，我们发现1没找到，所以第一个没出现的正数就是1。
 *
 * 所以我们看数组长度N，从1数到N。看下到底哪个正数是没出现的，那个第一个没出现的正数就是答案。
 *
 * 读懂题目后，我们最基本的思路就是：把1到N的数字都拿出来读一遍，看下每个数字在不在数组里，如果轮到哪个数字了，但是这个数字不在数组里，那么这个数字就是缺失的第一个正数。
 * 但如果都找到了，那么缺失的第一个正数就是N+1。所以缺失的第一个正数的取值范围一定是在1到N+1之间。
 *
 * - 假如题目不要求O(1)空间复杂度，那么我们可以直接用哈希表来解决。将题目输入的数组nums都放到Set中，然后我们从1到N+1开始读数，每读到一个数我们就看在不在Set中，第一个不在的就是答案。空间复杂度O(n)
 * - 假如题目不要求O(n)时间复杂度，那么我们可以直接从1到N+1读数，然后再遍历数组，看下当前数在不在数组中。逐一比对。相当于两个嵌套while循环。时间复杂度是O(n^2)
 *
 *
 *
 * @group 数组
 */
export const first_missing_positive = firstMissingPositive;
