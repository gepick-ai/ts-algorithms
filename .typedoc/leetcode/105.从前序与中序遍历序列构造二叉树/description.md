### 算法步骤

**核心思路**：
利用前序遍历确定根节点，利用中序遍历确定左右子树的范围，通过递归构建二叉树。

**关键步骤**：
1. 前序遍历的第一个元素是根节点
2. 在中序遍历中找到根节点位置，划分左右子树
3. 递归构建左右子树

**索引计算**：
- 左子树前序遍历起始：`preL + 1`
- 右子树前序遍历起始：`preL + lSize + 1`（其中 `lSize = mid - inL`）
- 左子树中序遍历范围：`[inL, mid - 1]`
- 右子树中序遍历范围：`[mid + 1, inR]`

**示例**：
```
前序遍历：[3, 9, 20, 15, 7]
中序遍历：[9, 3, 15, 20, 7]

步骤1：根节点为3，在中序遍历中位置为1
步骤2：左子树中序遍历[9]，右子树中序遍历[15, 20, 7]
步骤3：递归构建左右子树
```

**时间复杂度**：O(n)  
**空间复杂度**：O(n)

### 总结

通过前序遍历和中序遍历构建二叉树，关键点在于通过不断改变追踪索引，确定新子树的前序遍历和后序遍历的结果。

如果每一层都拿前一个子树的前序遍历结果，那么就无法确定新子树的根节点。

很容易错的地方在于正确处理了中序遍历的索引，但是没处理前序遍历的索引。理所当然认为不断shift preorder的头元素就是新子树的根。这是不对的。

左右子树的前序遍历节点范围是需要重新计算的。