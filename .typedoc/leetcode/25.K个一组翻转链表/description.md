### 算法步骤

#### 头插法

要反转链表的一部分，做法基本操作跟反转整条链表是一样的。同样需要设计三个指针pre、cur、nxt。其中pre指向当前节点的前一个节点，cur指向当前节点，nxt指向当前节点的下一个节点。利用头插法完成反转。同样地，pre、cur、nxt具有另一层意思：
- pre代表新链表的头节点
- cur代表准备插入到新链表的节点
- nxt代表下一个准备插入到新链表的节点，或者更简单地把它看成todo list。
在反转链表的一部分过后，pre指向了新链表的头节点，cur则指向了todo list的第一个节点。我们可以认为pre把链表分成了两部分，一部分是已经反转好的链表 + 反转部分的前一部分链表，一部分是待反转的链表。反转好的链表由pre开头，待反转的链表由cur开头。我们把反转好的链表的尾部的前一个节点叫做p0，p0的next指向反转好的链表的尾部。因此在反转部分链表完成后，我们把p0的next节点的next指向cur，然后让p0的next指向pre，这样子就完成了链表部分反转。

特殊情况，当left为1的时候，反转部分的前一个节点是无法找到p0的，为了统一逻辑，我们引入一个虚拟头节点dummy，让dummy的next指向head。这样子我们就可以认为当left为1的时候，p0就是dummy。

现在我们需要完成k个一组反转链表。那么我们其实就是在循环反转链表的一部分，做法基本跟上面反转一部分链表一样，只不过反转之前我们先判断下剩余节点个数，如果大于等于K，我们可以反转，否则我们退出循环。

需要注意的是，我们在多次反转链表的一部分的时候，p0不再是像上面那样固定不变的，而是需要每次反转前重新计算p0。将p0更新成下一段要反转的节点的上一个节点。而我们知道，在一部分反转结束之后，pre就是反转部分的头部，而cur在pre后边，如果反转部分后，其实pre代表的这段部分的尾部会接上cur，这个尾部实际上就是没完成拼接工作之前，p0的next节点，因此我们可以在修改前将这个节点保存起来。

### 总结

- 利用pre、cur、nxt三个指针，可以完成链表部分反转。
- 利用p0节点，可以完成链表部分反转后，重新拼接整条链表的收尾工作。具体点就是p0的next节点的next指向cur，然后让p0的next指向pre。