### 算法步骤

题目要求get和put时间复杂度在O(1)。那么需要找到符合get或者put复杂度在O(1)内，符合这样的常见结构有链表、哈希表、数组，同时满足的只有map。但是map没法表达"最久没用"这个概念，同时我们还需要在超出容量的时候O(1)删除最久没用的key，因此我们想到双链表：

* 设计双向链表list，越靠近头部，那么说明结点加入的时间越久远
* n1 <=> n2 <=> n3 <=> n4 <=> n5
* capacity代表链表的节点总数
* 但是双链表没法O(1)获取，于是我们加入哈希表结构，让整个数据结构能够以O(1)的方式获取。我们让key-node的映射关系存储在map当中
* 通过key迅速拿到node，然后拿到其中的value

注意：对于双链表，在进行get或者put操作后，需要更新相关节点，让其处于链表头部表示最近使用了，它应该从尾部删除，因为它不是最久没使用的了。

整体方案：实现新数据结构的"增、删、查、改"，利用哈希表+双链表实现这个数据结构。

![LRU缓存](../images/146.LRU缓存.png)